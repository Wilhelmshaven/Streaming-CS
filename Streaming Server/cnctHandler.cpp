#include "cnctHandler.h"

//直接初始化
cnctHandler *cnctHandler::instance = new cnctHandler;

//构造和析构
cnctHandler::cnctHandler()
{
	//VAR init
	WSAStartup(MAKEWORD(2, 2), &wsaData);
	srvPort = "8554";         //默认端口

	completionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);   //建立完成端口

	//获取并填写服务器信息：监听任意地址
	srvAddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);
	srvAddr.sin_family = AF_INET;
	srvAddr.sin_port = htons(stoi(srvPort, nullptr, 10));

	// 建立流式套接字，由于要使用重叠I/O，这里必须要使用WSASocket来初始化Socket
	srvSocket = WSASocketW(AF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);
	
	bind(srvSocket, (SOCKADDR *)&srvAddr, sizeof(srvAddr));
}
cnctHandler::~cnctHandler()
{
	//退出完成端口
	for (int i = 0; i < sysInfo.dwNumberOfProcessors; i++)
	{
		PostQueuedCompletionStatus(completionPort, 0, 0, NULL);
	}

	CloseHandle(completionPort);

	shutdown(srvSocket, SD_BOTH);
	closesocket(srvSocket);

	WSACleanup();
}

//一系列返回信息的函数
cnctHandler* cnctHandler::getInstance()
{
	return instance;
}

//设置服务器
int cnctHandler::srvConfig(string port)
{
	srvPort = port;

	return 0;
}

//获取系统信息
int cnctHandler::getSystemInfo()
{
	GetSystemInfo(&sysInfo);

	return 0;
}

//检查客户端是否活动
bool cnctHandler::isSocketAlive(SOCKET clientSocket)
{
	string msg = "isAlive?";
	int byteSent;

	byteSent = send(clientSocket, msg.c_str(), msg.size(), NULL);

	if (byteSent == -1)return false;
	else return true;
}

//建立工作者线程
int cnctHandler::buildThread()
{
	int cntThread = sysInfo.dwNumberOfProcessors;

	workerThread.resize(cntThread);

	for (int i = 0; i < cntThread; i++) {
		// 创建服务器工作器线程，并将完成端口传递到该线程
		workerThread[i] = CreateThread(NULL, NULL, workerThreadFunc, (LPVOID)completionPort, NULL, NULL);

		//CloseHandle(workerThread[i]);
	}

	return 0;
}

//启动服务器
int cnctHandler::startServer()
{						
	//真是傻逼了，前面那么多函数设计了都没调用……
	//真应该搞个防呆设计
	getSystemInfo();
	buildThread();

	listen(srvSocket, SOMAXCONN);                //将SOCKET设置为监听模式

	//徐行：这里必须NEW，否则创建线程后结构体被删除，就无法传入。线程中再删除
	acptThreadParam *param = new acptThreadParam;
	param->comp = completionPort;
	param->sock = srvSocket;

	CreateThread(NULL, NULL, acptThread, param, NULL, NULL);  //创建接收线程

	return 0;
}

//============监听线程，专门用于接收传入连接=============//
DWORD WINAPI cnctHandler::acptThread(LPVOID lparam)
{
	//处理传入参数
	acptThreadParam *param = (acptThreadParam *)lparam;
	HANDLE hCompletionPort = param->comp;
	SOCKET srvSocket = param->sock;
	delete lparam;

	LPPER_IO_DATA PerIoData;             //单IO数据
	LPPER_HANDLE_DATA PerHandleData;       //单句柄数据

	SOCKET acptSocket;                   //临时SOCKET

	SOCKADDR_IN clientAddr;
	int addrSize = sizeof(clientAddr);

	while (true)
	{
		//if (WaitForSingleObject(hSrvShutdown, 0))break;  //这个到底有没有用是个问题

		//接收连接
		//TODO：考虑更换成AcceptEx()：accept、WSAAccept是同步操作，AcceptEx是异步操作
		acptSocket = accept(srvSocket, (SOCKADDR*)&clientAddr, &addrSize);

		//保存客户端信息
		PerHandleData = (LPPER_HANDLE_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(LPPER_HANDLE_DATA));
		PerHandleData->clientAddr = clientAddr;
		PerHandleData->clientSocket = acptSocket;

		//将接受套接字和完成端口关联
		CreateIoCompletionPort((HANDLE)acptSocket, hCompletionPort, (DWORD)PerHandleData, 0);

		//准备一个重叠I/O
		PerIoData = (LPPER_IO_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(LPPER_IO_DATA));	
		ZeroMemory(&(PerIoData->overlapped), sizeof(OVERLAPPED));   //这个清零很重要！！否则会导致GetQueuedCompletionStatus不返回

		PerIoData->wsaBuf.len = BUF_SIZE;              //缓存为最大
		PerIoData->wsaBuf.buf = PerIoData->buffer;     //缓存
		PerIoData->operationType = compRecv;	       //设置模式为接收
			
		//在新建的套接字上投递一个或多个异步WSARecv或WSASend请求，并立即返回
		WSARecv(PerHandleData->clientSocket, &PerIoData->wsaBuf, 1, &PerIoData->bytesRecv, &PerIoData->flags,
			&(PerIoData->overlapped), NULL);
	}

	return 0;
}

//==========工作者线程===========//
DWORD WINAPI cnctHandler::workerThreadFunc(LPVOID lparam)
{	
	//处理传入参数
	HANDLE hCompletionPort = (HANDLE)lparam;

	SOCKET clientSocket;

	DWORD bytesTransferred;
	DWORD flags;

	LPPER_HANDLE_DATA handleInfo;
	LPPER_IO_DATA ioInfo;
	
	string buf;

	while (true)
	{
		//得到完成端口的状态
		//相关数据已经在2-4的参数里面了：第二个指示收到的字节数，第三个是客户端信息，第四个是相关接收数据
		GetQueuedCompletionStatus(hCompletionPort, &bytesTransferred, (LPDWORD)&handleInfo, (LPOVERLAPPED *)&ioInfo, INFINITE);

		//结束服务器？
		if (WaitForSingleObject(hSrvShutdown, 0))break;  //这个到底有没有用是个问题

		clientSocket = handleInfo->clientSocket;

		//首先解析收到的信息
		//首先确认，这个是控制信令，还是流媒体信令
		//TODO：那么我需要设计控制指令了






		//准备下一个，投递一个WSARecv
		//准备一个重叠I/O
		ioInfo = (LPPER_IO_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(LPPER_IO_DATA));
		ZeroMemory(ioInfo, sizeof(ioInfo));

		ioInfo->wsaBuf.len = BUF_SIZE;             //缓存为最大
		ioInfo->wsaBuf.buf = ioInfo->buffer;       //缓存
		ioInfo->operationType = compRecv;	       //设置模式为接收

		WSARecv(clientSocket, &(ioInfo->wsaBuf), 1, NULL, &flags, &(ioInfo->overlapped), NULL);
	}

	return 0;
}